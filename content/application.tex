Das Szenario der \textit{CloudTieringDemo} zeigt, wie eine grafische webbasierte Schnittstelle für \ac{COS} erzeugt werden kann, die zusätzlich die Analyse von hoch geladenen Bildern ermöglicht. Das Aufsetzen des notwendigen Spectrum Scale Clustern wurde hierbei in den vorherigen Abschnitten beschrieben.
Dieser Teil der Beschreibung umfasst das Entwickeln der Cloudanwendung, Aufsetzen und Einrichten auf Bluemix mithilfe einer \ac{CD}-Pipeline und \gls{Git} zur Versionsverwaltung. Anhand dieses Beispieles sollen die Möglichkeit der Kombination verschiedener Dienste verdeutlicht und eine wiederverwendbare Architektur erzeugt werden. Diese kann dann in anderen Projekten als Schnellstart dienen.

\begin{center}
	\colorbox{gray}{\parbox{0.9\textwidth}{Der Code der Anwendung kann von GitLab heruntergeladen werden und steht öffentlich zur Verfügung: \url{https://git.ng.bluemix.net/simuelle/CloudTieringDemo}}}
\end{center}

\subsection{Architektur der Anwendung}
An dieser Stelle werden die wichtigsten Teil der Anwendung untersucht, visualisiert und in ein Verhältnis zueinander gestellt. Dafür werden Kontext-, Operations- und Klassendiagramme zur Verfügung gezeigt und erläutert.

Die auf Bluemix laufende Anwendung besteht aus mehreren Komponenten für Frontend und Backend. Auf der einen Seite gibt es einen auf Node.js basierenden Anwendungsserver, der die eigentliche Logik der Anwendung kapselt und mithilfe einer \gls{REST}-Schnittstelle verschiedene Dienste bereitstellt.

Wie in \autoref{fig:democontextdiagram} zu sehen ist, kommuniziert die Anwendung mit zwei externen Ressourcen. Eine von diesen ist der Spectrum Scale Cluster angebunden an den \ac{COS} mithilfe von Cloud Sharing und die andere ist die Deep Learning Software zur Bildanalyse von IBM Watson.

\begin{figure}[hbt]
	\centering
	\includegraphics[scale=0.75]{images/demo-context-diagram}
	\caption{Kontextdiagramm der Demo}
	\label{fig:democontextdiagram}
\end{figure}

In \autoref{fig:demosequenzdiagram} sieht man eine typische Aktionssequenz, ausgelöst durch einen Nutzeraktion. Der hier dargestellte Hochladeprozess kann stellvertretend für alle Aktionen zwischen Client (Internetbrowser des Nutzers) und \ac{COS} betrachtet werden.
Zuerst wird ein asynchroner Request an den Node.js Applikationsserver gestellt, dieser erzeugt einen Request für den \ac{COS}-Server und sendet danach die Daten bzw. eine Bestätigung des Uploads an den Nutzer.
Beim Scheitern der Anfrage wird eine entsprechende Fehlermeldung an den Browser gesendet.

\begin{figure}[hbt]
	\centering
	\includegraphics[scale=0.85]{images/demo-sequenz-diagram}
	\caption{Sequenz-Diagramm des Hochladeprozesses in der Demo}
	\label{fig:demosequenzdiagram}
\end{figure}

Ein Spezialfall stellt hierbei die Bildanalyse durch den Watsondienst dar (\autoref{fig:demosequenzdiagramwatson}). Das ausgewählte Bild muss erst akquiriert werden und wird dann zum Visual Recognition-Server hochgeladen. Nachdem dieser entsprechende Metadaten für die Bilddatei erzeugt hat, werden sie ebenfalls im Cloudspeicher abgelegt und eine Bestätigung an den Nutzer gesendet.
Diese kann einige, ausgewählte Erkenntnisse über die Datei enthalten.

\begin{figure}[hbt]
	\centering
	\includegraphics[scale=0.75]{images/demo-sequenz-diagram-watson}
	\caption{Sequenz-Diagramm der Bildanalyse mit Watson in der Demo}
	\label{fig:demosequenzdiagramwatson}
\end{figure}

\textbf{Backend}\\
Der mit Node.js und Express laufende Server implementiert eine leicht abgeändertes \ac{MVC} Framework. Betrachtet man die Ordnerstruktur repräsentiert diese die einzelnen Bestandteile des Entwicklungsmusters.

\begin{itemize}
	\item \textbf{app.js}:\\
	Die Hauptdatei des Servers, die beim Starten ausgeführt wird. Hier werden notwendige Pakete initialisiert, weitergereicht und der Webserver konfiguriert.
	\item \textbf{controller/}:\\
	Die REST-Controller der Anwendung. Werden ausgeführt, wenn bestimmte ULRs aufgerufen wurden und delegieren Aufgaben an die Anwendungslogik. Sie übernehmen die gesamte Kommunikation mit der Frontendanwendung (Auslieferung von HTML-Inhalten oder REST-Antworten) und sorgen für eine einheitliche Formatierung der Antworten.
	\item \textbf{services/}:\\
	An dieser Stelle findet die gesamte Anwendungslogik und Datenmodellveränderung statt. Anfragen an \ac{COS} für den Datenaustausch starten hier, ebenso wie die Kommunikation mit anderen Diensten.
	Dedizierte Service Klassen können an jeden Controller übergeben werden und sind somit an verschiedenen Stelle der Anwendung benutzbar.
	\item \textbf{views/ und public/}:\\
	Im \textit{views/-Ordner} liegen alle Vorlagen für die HTML-Inhalte zur Auslieferung an das Frontend. Da im \ac{UI} auch Logik und Styling verwendet werden soll, liegen alle, von den HTML-Seiten verwendeten Skripte und Stylesheets, im \textit{public/-Ordner}.
	Diese sind aufgeteilt in Javascript-, CSS- und Bilddateien.
	\item \textbf{Sonstige Ordner und Dateien}:\\
	Zusätzlich gibt es noch eine Paketbeschreibung (\autoref{tab:npmpackages}) in der \textit{package.json} mit dem \textit{node\_modules/-Ordner} für die tatsächlichen Module und einen \textit{config/-Verzeichnis} für Einstellungen der Anwendung. Für das temporäre Speichern von Dateien wird der \textit{file\_cache/-Ordner} verwendet.
\end{itemize}

In der Implementierungsbeschreibung wird das Aufsetzen einer typischen Ablaufsequenz, inklusive aller anzupassenden Dateien, demonstriert.\\

\textbf{Frontend}\\
Wie oben beschrieben, existieren ebenfalls einige Dateien für das Frontend. Sie sorgen dafür, dass eine dynamische, anpassungsfähige und ästhetische Benutzung des Interface möglich ist.

Dies setzt natürlich auch eine gewisse Architektur voraus, damit eine leichte Erweiterung möglich ist. Somit liegt im Frontend folgende Ordnerstruktur vor:

\begin{itemize}
	\item \textbf{views/}: Die HTML-Vorlagen für die einzelnen Seiten der Anwendung
	\item \textbf{public/}
	\begin{itemize}
		\item \textbf{css/}:\\
		Hier liegt ein generelles Stylesheet (\textit{style.css}) für alle Seiten und spezialisierte Dateien für jede einzelne View.
		\item \textbf{img/}:\\
		Ein Speicherort für alle Bilddateien, die im Frontend verwendet werden
		\item \textbf{js/}:\\
		Das Wurzelverzeichnis für alle Javascriptdateien, die für die Logik der \ac{UI} benutzt werden. Auf der obersten Eben liegen dedizierte Skripts, die beim Ausführen der Seite ausgeführt werden.
		\begin{itemize}
			\item \textbf{controller/}:\\
			Controller, die Veränderung an der HTML-Datei auslösen und dynamische Änderungen, ohne Neuladen der Seite, erzeugen können 
			\item \textbf{services/}:\\
			Bestimmte Dienste sind hier angelegt, zum Beispiel die \gls{AJAX}-Kommunikation mit dem Backend. Sie sind von überall erreichbar und bieten verschiedene statische Methoden. Vergleichbar mit den serverseitigen Services.
		\end{itemize}
	\end{itemize}
\end{itemize}

Das Frontend spielt in dieser Anwendung eine untergeordnete Rolle (im Sinne eines schwachen Klienten) und es wird auch bei der Implementierungsbeschreibung hauptsächlich Wert auf die Serverstrukturen gelegt. Theoretisch kann die bestehende \ac{UI} leicht durch eine andere ausgewechselt werden, da nur eine lose Kopplung durch die \gls{REST}-API besteht.

\subsection{Implementierung}
\todo{Mit Bilder umschreiben}

Bevor die Implementierung gestartet werden kann, sollten einige Grundvoraussetzungen erfüllt sein:

\begin{itemize}
	\item Softlayer Cloud Object Storage Account mit S3-API(IBM COS)
	\item IBM Bluemix Account
	\item IBM Bluemix Kommandozeilen Werkzeug
	\item Node.js Version > 6.0.0
	\item \gls{Git}
\end{itemize}

Um diese Voraussetzungen zu erreichen, existiert eine umfangreiche Dokumentation in folgender Quelle: \cite[S. 129]{Rios.2017}. An dieser Stelle wird nur grob auf das Setup eingegangen und mehr auf die eigentliche Implementierung fokussiert.

Nach erfolgreichen Anlegen der Benutzeraccounts und Installation der lokalen Tools, kann die Cloud Foundry-Anwendung angelegt werden. Hierzu muss zuerst die Anmeldung auf Bluemix erfolgen und die Navigation auf das Dashboard. Hier können neue Applikationen erzeugt werden. In unserem Anwendungsfall wird die Node.js Laufzeit Umgebung erzeugt, es muss nur ein eindeutiger Name für die App und die URL-Route ausgewählt werden.

Innerhalb weniger Momente sollte eine einfach Basisanwendung erreichbar sein. Um den Quellcode bearbeiten zu können, kann dieser Entweder mit dem Bluemix Kommandozeilen Tool heruntergeladen oder ein Git-Verzeichnis erzeugt werden. Zweites ist wesentlich mächtiger, da sowohl eine vollständige Versionsverwaltung wie auch eine \ac{CD}-Pipeline zur Verfügung steht. Um sie zu erzeugen, muss im Dashboard die neue Anwendung ausgewählt und eine neue Toolchain erstellt werden. Es steht nun eine GitLab Umgebung und eine Standard konfigurierte Pipleine zur Verfügung.

Durch die normalen Einstellung der Toolchain werden automatisch Git-Commits auf den \textit{master}-Zweig auf Bluemix deployed. Wenn ein Projekt mehreren Beitragenden hat, sollte dieses Verhalten verändert werden.

Mithilfe von \gls{Git} kann nun der Starter-Code heruntergeladen und für diesen Nutzungsfall angepasst werden.

Zuerst sollte die oben beschriebene Ordnerstruktur erzeugt und alle NPM-Abhängigkeiten installiert werden:

\begin{lstlisting}[language=bash, caption=Paket Installation und package.json erzeugung]
npm install aws-sdk body-parser bootstrap cfenv ejs express filesize jquery moment morgan multer promise toastr watson-developer-cloud --save
\end{lstlisting}

Die Anwendung lässt sich lokal zum Testen mit \lstinline|npm start| oder \lstinline|node app.js| starten.
 
Danach kann die \textit{app.js} angepasst werden, um den Grundstein für erste Routen und Seiten zu legen. An dieser Stelle wird eine gekürzte Version gezeigt, die nur den generellen Aufbau beleuchten sol.

\begin{lstlisting}[language=JavaScript, caption=Anpassung der Hauptdatei der Anwendung]
// DEPENDENCIES
const express = require('express');
... 
// EXPRESS SETUP
let app = express();
...
//STATIC FILE SERVING
app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/file_cache'));
app.use('/bootstrap', express.static(__dirname + '/node_modules/bootstrap/dist'));
app.use('/jquery', express.static(__dirname + '/node_modules/jquery/dist'));
...
//VIEW ENGINE
app.set('view engine', 'ejs');
app.set('views',__dirname + '/views');

//SERVICES
const cosService = require('./services/cosService')(config);
...
//ROUTING
app.use('/api/v1', require('./controller/cosCtrl')(cosService, upload));
app.use('/', require('./controller/viewCtrl')());

//SERVER SETUP
app.listen(cfenv.getAppEnv().port, '0.0.0.0', function() { ... });
\end{lstlisting}

Im ersten Teil werden alle Abhängigkeiten der Anwendung geladen. Dies ist wichtig, damit keine mehrfache Initialisierung von bestimmten Modulen in der Anwendung stattfindet. Im nächsten Teil wird express mit verschiedener Middleware kombiniert und die statischen Ordner für Dateiauslieferung definiert. Für diese agiert express dann wie ein klassischer Dateiserver.
Im nächsten Schritt werden alle vom Nutzer definierten Dienste erstellt. Diese können dann im nächsten Abschnitt an die Controller weitergereicht werden, sofern Bedarf besteht.
Es gibt genau einen \lstinline|viewCtrl|, der zur Auslieferung der HTML-Vorlagen verwendet wird. Für jede neue Seite der \ac{UI} muss hier eine weitere GET-Route angelegt werden, die aus dem korrespondierenden EJS-Tempalte das HTML generiert.
EJS ist hierbei ein Vorlagensprache, die Inline-Javascript ermöglicht und die Erzeugung von HTML-Seiten erleichtert.

Alle anderen Controller dienen zum Definieren der REST-Schnittstelle der Anwendung (zum Beispiel der \lstinline|cosCtrl|). Im letzten Teil der \textit{app.js} wird der HTTP-Server gestartet und aus den Bluemix-Umgebungsvariabeln der Port ausgelesen. Lokal wird hierbei einfach ein freier verwendet.\\

\textbf{Erzeugung eine REST-Schnittstellen Funktion}\\
\textbf{Erzeugung einer Frontend-Seite mit Backend Anbindung über AJAX}\\
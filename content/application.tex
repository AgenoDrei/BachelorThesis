Das Szenario der \textit{CloudTieringDemo} zeigt, wie eine grafische, webbasierte Schnittstelle für \ac{COS} erzeugt werden kann, die zusätzlich die Analyse von hoch geladenen Bildern ermöglicht. Das Aufsetzen des notwendigen Spectrum Scale Clustern wurde hierbei in den vorherigen Abschnitten beschrieben.
Dieser Teil der Beschreibung umfasst das Entwickeln der Cloudanwendung, Aufsetzen und Einrichten auf Bluemix mithilfe einer \ac{CD}-Pipeline und \gls{Git} zur Versionsverwaltung. Anhand dieses Beispieles sollen die Möglichkeit der Kombination verschiedener Dienste verdeutlicht und eine wiederverwendbare Architektur erzeugt werden. Diese kann dann in anderen Projekten als Schnellstart dienen.

\begin{center}
	\colorbox{gray}{\parbox{0.9\textwidth}{Der Code der Anwendung kann von GitLab heruntergeladen werden und steht öffentlich zur Verfügung: \url{https://git.ng.bluemix.net/simuelle/CloudTieringDemo}}}
\end{center}

\subsection{Architektur der Anwendung}
An dieser Stelle werden die wichtigsten Teile der Anwendung untersucht, visualisiert und in ein Verhältnis zueinander gestellt. Dafür werden Kontext-, Operations- und Klassendiagramme gezeigt und erläutert.

Die auf Bluemix laufende Anwendung besteht aus mehreren Komponenten für Frontend und Backend. Auf der einen Seite gibt es einen auf Node.js basierenden Anwendungsserver, der die eigentliche Logik der Anwendung kapselt und mithilfe einer \gls{REST}-Schnittstelle verschiedene Dienste bereitstellt.

Wie in \autoref{fig:demoarchitectureoverview} zu sehen ist, kommuniziert die Anwendung mit zwei externen Ressourcen. Eine von diesen ist der Spectrum Scale Cluster angebunden an den \ac{COS} mithilfe von Cloud Sharing und die andere ist die Deep Learning Software zur Bildanalyse von IBM Watson.

\begin{figure}[hbt]
	\centering
	\includegraphics[scale=0.75]{images/demo-context-diagram}
	\caption{Kontextdiagramm der Demo}
	\label{fig:democontextdiagram}
\end{figure}

In \autoref{fig:demosequenzdiagram} sieht man eine typische Aktionssequenz, ausgelöst durch einen Nutzer. Der hier dargestellte Hochladeprozess kann stellvertretend für alle Aktionen zwischen Client (Internetbrowser des Nutzers) und \ac{COS} betrachtet werden.
Zuerst wird ein asynchroner Request an den Node.js Applikationsserver gestellt, dieser erzeugt einen Request für den \ac{COS}-Server und sendet danach die Daten bzw. eine Bestätigung des Uploads an den Nutzer.
Beim Scheitern der Anfrage wird eine entsprechende Fehlermeldung an den Browser gesendet.

\begin{figure}[hbt]
	\centering
	\includegraphics[scale=0.85]{images/demo-sequenz-diagram}
	\caption{Sequenz-Diagramm des Hochladeprozesses in der Demo}
	\label{fig:demosequenzdiagram}
\end{figure}

Ein Spezialfall stellt hierbei die Bildanalyse durch den Watsondienst dar (\autoref{fig:demosequenzdiagramwatson}). Das ausgewählte Bild muss erst akquiriert werden und wird dann zum Visual Recognition-Server hochgeladen. Nachdem dieser entsprechende Metadaten für die Bilddatei erzeugt hat, werden sie ebenfalls im Cloudspeicher abgelegt und eine Bestätigung an den Nutzer gesendet.
Diese kann einige ausgewählte Erkenntnisse über die Datei enthalten.

\begin{figure}[hbt]
	\centering
	\includegraphics[scale=0.75]{images/demo-sequenz-diagram-watson}
	\caption{Sequenz-Diagramm der Bildanalyse mit Watson in der Demo}
	\label{fig:demosequenzdiagramwatson}
\end{figure}

\textbf{Backend}\\
Der mit Node.js und Express laufende Server implementiert eine leicht abgeändertes \ac{MVC} Framework. Betrachtet man die Ordnerstruktur repräsentiert diese die einzelnen Bestandteile des Entwicklungsmusters.

\begin{itemize}
	\item \textbf{app.js}:\\
	Die Hauptdatei des Servers, die beim Starten ausgeführt wird. Hier werden notwendige Pakete initialisiert, weitergereicht und der Webserver konfiguriert.
	\item \textbf{controller/}:\\
	Die REST-Controller der Anwendung werden ausgeführt, wenn bestimmte ULRs aufgerufen wurden und delegieren Aufgaben an die Anwendungslogik. Sie übernehmen die gesamte Kommunikation mit der Frontendanwendung (Auslieferung von HTML-Inhalten oder REST-Antworten) und sorgen für eine einheitliche Formatierung der Antworten.
	\item \textbf{services/}:\\
	An dieser Stelle findet die gesamte Anwendungslogik und Datenmodellveränderung statt. Anfragen an \ac{COS} für den Datenaustausch starten hier, ebenso wie die Kommunikation mit anderen Diensten.
	Dedizierte Service Klassen können an jeden Controller übergeben werden und sind somit an verschiedenen Stelle der Anwendung benutzbar.
	\item \textbf{views/ und public/}:\\
	Im \textit{views/-Ordner} liegen alle Vorlagen für die HTML-Inhalte zur Auslieferung an das Frontend. Da im \ac{UI} auch Logik und Styling verwendet werden sollen, liegen alle von den HTML-Seiten verwendeten Skripte und Stylesheets im \textit{public/-Ordner}.
	Diese sind aufgeteilt in Javascript-, CSS- und Bilddateien.
	\item \textbf{Sonstige Ordner und Dateien}:\\
	Zusätzlich gibt es noch eine Paketbeschreibung (\autoref{tab:npmpackages}) in der \textit{package.json} mit dem \textit{node\_modules/-Ordner} für die tatsächlichen Module und einen \textit{config/-Verzeichnis} für Einstellungen der Anwendung. Für das temporäre Speichern von Dateien wird der \textit{file\_cache/-Ordner} verwendet.
\end{itemize}

Im \autoref{subsec:implementation} wird das Aufsetzen einer typischen Ablaufsequenz, inklusive aller anzupassenden Dateien, umgesetzt.\\

\textbf{Frontend}\\
Wie oben beschrieben, existieren ebenfalls einige Dateien für das Frontend. Sie sorgen dafür, dass eine dynamische, anpassungsfähige und ästhetische Benutzung des Interfaces möglich ist.

Dies setzt natürlich auch eine gewisse Architektur voraus, die eine leichte Erweiterbarkeit ermöglicht. Somit liegt im Frontend folgende Ordnerstruktur vor:

\begin{itemize}
	\item \textbf{views/}: Die HTML-Vorlagen für die einzelnen Seiten der Anwendung
	\item \textbf{public/}
	\begin{itemize}
		\item \textbf{css/}:\\
		Hier liegt ein generelles Stylesheet (\textit{style.css}) für alle Seiten und spezialisierte Dateien für jede einzelne Ansicht.
		\item \textbf{img/}:\\
		Ein Speicherort für alle Bilddateien, die im Frontend verwendet werden
		\item \textbf{js/}:\\
		Das Wurzelverzeichnis für alle Javascriptdateien, die für die Logik der \ac{UI} benutzt werden. Auf der obersten Eben liegen dedizierte Skripts, die beim Ausführen der Seite ausgeführt werden.
		\begin{itemize}
			\item \textbf{controller/}:\\
			Controller, die Veränderungen an der HTML-Datei auslösen und dynamische Änderungen, ohne Neuladen der Seite, erzeugen können 
			\item \textbf{services/}:\\
			Bestimmte Dienste sind hier angelegt, zum Beispiel die \gls{AJAX}-Kommunikation mit dem Backend. Sie sind von überall erreichbar und bieten verschiedene statische Methoden. Vergleichbar mit den serverseitigen Services.
		\end{itemize}
	\end{itemize}
\end{itemize}

Das Frontend spielt in dieser Anwendung eine untergeordnete Rolle (im Sinne eines Thin-Client) und es wird auch bei der Implementierungsbeschreibung hauptsächlich Wert auf die Serverstrukturen gelegt. Theoretisch kann die bestehende \ac{UI} leicht durch eine andere ausgewechselt werden, da nur eine lose Kopplung durch die \gls{REST}-API besteht.

\subsection{Implementierung}\label{subsec:implementation}

Bevor die Implementierung gestartet werden kann, sollten einige Grundvoraussetzungen erfüllt sein:

\begin{itemize}
	\item Softlayer Cloud Object Storage Account mit S3-API(IBM COS)
	\item IBM Bluemix Account
	\item IBM Bluemix Kommandozeilen Werkzeug
	\item Node.js Version > 6.0.0
	\item \gls{Git}
\end{itemize}

Um diese Voraussetzungen zu erfüllen, existiert eine umfangreiche Dokumentation in folgender Quelle: \cite[S. 129]{Rios.2017}.

An dieser Stelle wird nur grob auf das Setup eingegangen und mehr auf die eigentliche Implementierung fokussiert.

Nach erfolgreichem Anlegen der Benutzeraccounts und Installation der lokalen Tools kann die Cloud Foundry-Anwendung angelegt werden. Hierzu muss zuerst die Anmeldung auf Bluemix erfolgen und die Navigation auf das Dashboard. Hier können neue Applikationen erzeugt werden. In unserem Anwendungsfall wird die Node.js Laufzeit Umgebung erzeugt, es muss nur ein eindeutiger Name für die App und die URL-Route ausgewählt werden.

Innerhalb weniger Momente sollte eine einfache Basisanwendung erreichbar sein. Um den Quellcode bearbeiten zu können, kann dieser entweder mit dem Bluemix Kommandozeilen Tool heruntergeladen oder ein Git-Verzeichnis erzeugt werden. Zweites ist wesentlich mächtiger, da sowohl eine vollständige Versionsverwaltung wie auch eine \ac{CD}-Pipeline zur Verfügung steht. Um sie zu erzeugen, muss im Dashboard die neue Anwendung ausgewählt und eine neue Toolchain erstellt werden. Es steht nun eine GitLab Umgebung und eine Standard konfigurierte Pipeline zur Verfügung.

Durch die normale Einstellung der Toolchain werden automatisch Git-Commits auf den \textit{master}-Zweig auf Bluemix angewendet. Wenn ein Projekt kompliziertet ist oder mehrere Beteiligte hat, sollte dieses Verhalten verändert werden.

Mithilfe von \gls{Git} kann nun der Starter-Code heruntergeladen und für diesen Nutzungsfall angepasst werden.

Zuerst sollte die oben beschriebene Ordnerstruktur erzeugt und alle NPM-Abhängigkeiten installiert werden:

\begin{lstlisting}[language=bash, caption=Paket Installation und package.json Erzeugung]
npm install aws-sdk body-parser bootstrap cfenv ejs express filesize jquery moment morgan multer promise toastr watson-developer-cloud --save
\end{lstlisting}

Die Anwendung lässt sich lokal zum Testen mit \lstinline|npm start| oder \lstinline|node app.js| starten.
 
Danach kann die \textit{app.js} angepasst werden, um den Grundstein für erste Routen und Seiten zu legen. An dieser Stelle wird eine gekürzte Version gezeigt, die nur den generellen Aufbau beleuchten soll.

\begin{lstlisting}[language=JavaScript, caption=Anpassung der Hauptdatei der Anwendung]
// DEPENDENCIES
const express = require('express');
... 
// EXPRESS SETUP
let app = express();
...
//STATIC FILE SERVING
app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/file_cache'));
app.use('/bootstrap', express.static(__dirname + '/node_modules/bootstrap/dist'));
app.use('/jquery', express.static(__dirname + '/node_modules/jquery/dist'));
...
//VIEW ENGINE
app.set('view engine', 'ejs');
app.set('views',__dirname + '/views');

//SERVICES
const cosService = require('./services/cosService')(config);
...
//ROUTING
app.use('/api/v1', require('./controller/cosCtrl')(cosService, upload));
app.use('/', require('./controller/viewCtrl')());

//SERVER SETUP
app.listen(cfenv.getAppEnv().port, '0.0.0.0', function() { ... });
\end{lstlisting}

Im ersten Teil werden alle Abhängigkeiten der Anwendung geladen. Dies ist wichtig, damit keine mehrfache Initialisierung von bestimmten Modulen in der Anwendung stattfindet. Im nächsten Teil wird express mit verschiedener Middleware kombiniert und die statischen Ordner zur Dateiauslieferung definiert. Für diese agiert express dann wie ein klassischer Dateiserver.
Im nächsten Schritt werden alle vom Nutzer definierten Dienste erstellt. Diese können dann im nächsten Abschnitt an die Controller weitergereicht werden, sofern Bedarf besteht.
Es gibt genau einen \lstinline|viewCtrl|, der zur Auslieferung der HTML-Vorlagen verwendet wird. Für jede neue Seite der \ac{UI} muss hier eine weitere GET-Route angelegt werden, die aus dem korrespondierenden EJS-Template das HTML generiert.
EJS ist hierbei ein Vorlagensprache, die Inline-Javascript ermöglicht und die Erzeugung von HTML-Seiten erleichtert.

Alle anderen Controller dienen zum Definieren der REST-Schnittstelle der Anwendung (zum Beispiel der \lstinline|cosCtrl|). Im letzten Teil der \textit{app.js} wird der HTTP-Server gestartet und aus den Bluemix-Umgebungsvariabeln der Port ausgelesen. Lokal wird hierbei einfach ein freier Port verwendet.\\

\textbf{Erzeugung eine REST-Schnittstellen Funktion}\\
An dieser Stelle betrachten wir die Implementierung der REST-Schnittstelle zum Löschen von Dokumenten in \ac{COS}-Dateispeichersystem. Dieses kann als exemplarisch betrachtet werden, da nach dem gleichen Entwicklungsmuster auch alle anderen API-Funktionen der Anwendung umgesetzt wurden. 

An erster Stelle muss der Controller erstellt werden, hierfür wird die Router Middleware von express verwendet. Mithilfe von dieser können logisch zusammenhängende URL-Routen innerhalb einzelner Module gegliedert werden. Das Löschen von Objekten wird hier in den \lstinline|CosCtrl| eingeordnet, der sämtliche direkte Interaktionen mit dem Dateispeicher verwaltet:\\

\begin{lstlisting}[language=JavaScript, caption=CosCtrl.js mit einer Route zur Dateilöschung]
const express = require('express');
const router = express.Router();

module.exports = function(cosService) {

	router.delete('/files/:id*', function(req, res) {
		let id = req.params.id + req.params[0];

		cosService.removeFile(id).done(function(data) {
			let response = {msg: 'File delete successful', delete: data};
			res.json(response);
		},
		function(err) {
			res.status(500).send(err);
		});
	});

	return router;
}
\end{lstlisting}

In den ersten beiden Zeilen wird der hier verwendete Router importiert. In der folgenden Zeile definiert die Initalisierungsfunktion das Moduls, in dem auch der hier verwendete \lstinline|cosService| übergeben wird.

Der nächste Block definiert nun die eigentliche Route: Diese verarbeitet nur DELETE HTTP Anfragen, die auf eine spezielle Route gemappt werden. Sofern die Basis-URL übereinstimmt, wird jeder Dateischlüssel (\lstinline|:id*|) angenommen. Der Schlüssel wird als nächstes ausgelesen und die entsprechende Servicefunktion übergeben. Deren Funktionsweise wird nach diesem Controller erklärt.

Da \gls{Promise}s Verwendung finden, kann eine der beiden definierten Funktionen abhängig vom Ergebnis des Nutzerdienstes aufgerufen werden. Die erste erzeugt eine Antwort für den Klienten und übergibt die später generierte Bestätigung von \ac{COS}. Im Fehlerfall wird ein HTTP Errorcode und der entstandene Fehler zurückgesendet.

Um das Modul nutzbar zu machen, muss jetzt nur noch der Service definiert werden:\\

\begin{lstlisting}[language=JavaScript, caption=CosService.js für die Kommunikation mit IBM COS]
const Promise = require('promise');
const aws = require('aws-sdk');

module.exports = function(config) {
	this.config = config;
	aws.config.loadFromPath(__dirname + '/../config/aws.json');
	this.ep = new aws.Endpoint(config.cos.endpoint);
	this.s3 = new aws.S3({ endpoint: this.ep });
	this.bucket = config.cos.bucket;
	
	this.removeFile = function(key) {
		return new Promise(function(fulfill, reject) {
			let params = {Bucket: this.bucket, Key: key};
			this.s3.deleteObject(params, function(err, data) {
				if(err) {
					reject(err);
				} else {
					fulfill(data);
				}
			});
		});
	};
	return this;
}
\end{lstlisting}

Zu Beginn werden wieder notwendige externe Module importiert und die Initialisierungsfunktion definiert. Informationen über Authentifizierung für \ac{COS} werden in der \lstinline|config| zentral von der Hauptdatei, welche aus dem globalen Konfigurationsfile \lstinline|config/config.js| liest, übergeben.

Mithilfe dieser wird der \ac{S3}-Klient und der richtige Bucket für die Anwendung erzeugt. 

In der eigentlichen Funktion wird ein Promise-Wrapper zum Ansprechen der relevante S3-API erzeugt. Das Ergebnis wird über die Promise-Funktionen zurückgegeben.

Als letztes müssen nun nur noch der Service in der \lstinline|app.js| erstellt und an den Router übergeben werden. Danach kann der gestartete Server mit der neuen REST-URL angesprochen werden:\\

\begin{lstlisting}[language=JavaScript, caption=Einbindung der neuen Route in der app.js]
const cosService = require('./services/cosService')(config);
app.use('/api/v1', require('./controller/cosCtrl')(cosService));
\end{lstlisting}

\textbf{Erzeugung einer Frontend-Seite mit Backend Anbindung über AJAX}\\
Für die graphische Repräsentation existiert ebenfalls ein Arbeitsablauf: Zuerst muss eine EJS-Vorlage erstellt werden. Bei dieser handelt es sich, um eine erweiterte HTML-Datei. Es können ähnlich wie bei PHP andere Dateien (hier ein Header) eingebunden und die Sprache mit dynamischen Variablen erweitert werden.

Die neue Route muss im \lstinline|ViewCtrl| des Backends festgelegt werden:\\

\begin{lstlisting}[language=JavaScript, caption=Definition einer neuen Frontendroute in der viewCtrl.js]
router.get('/file/', function (req, res) {
	res.render('fileUpload');
});
\end{lstlisting}

An dieser Stelle kann man sehen, wie beim Ansprechen der URL eine neue HTML-Seite aus dem EJS-Template mit der \lstinline|render|-Funktion von express generiert wird.

Für jede Seite im Frontend gibt es eine eigenen CSS-Style, eine Initialisierungsdatei und einen Controller, der Veränderungen vornimmt. Diese Dateien werden statisch aus dem \lstinline|public/|-Verzeichnis ausgeliefert.

Das Erstellen der Seite zum Hochladen von Dateien wird hier als Beispiel untersucht und einige Codebeispiele betrachtet: \\

\begin{lstlisting}[language=JavaScript, caption=Initalisierungsfunktion der Uploadseite in der fileUpload.js]
let ctrl = null;
let main = function() {
	ctrl = new FileUploadCtrl();
};

let submitFile = function() {
	...
};

$( document ).ready(main);
\end{lstlisting}

Nachdem das Dokument geladen wurde, wird zuerst die \lstinline|main|-Funktion ausgeführt und der Controller für die Seite erstellt. Die hier angedeutete \lstinline|submitFile|-Routine sendet einen POST-Request zum Server mit der angehängten Datei. Beim Erfolg der Routine gibt der \lstinline|FileUploadCtrl| ein positives Feedback an das Frontend:\\

\begin{lstlisting}[language=JavaScript, caption=Initalisierungsfunktion der Uploadseite in der fileUpload.js]
class FileUploadCtrl {
	constructor() {
		$("#tabs>li.active").removeClass("active");
		$("#fileUploadTab").addClass("active");
		$("#reload-btn").hide();
	}

	uploadSuccess(result) {
		toastr.success('File upload successfull');
	}

	uploadError(error) {
		toastr.error('File upload failed');
	}
}        
\end{lstlisting}

Hier wird ein Toast erzeugt für den Erfolgs- oder Fehlerfall. Bei Erzeugung des Controllers wird die Navigation aktualisiert und der Tab auf aktiv gesetzt.

Bei anderen Seiten werden auch Services verwendet, die aber ungefähr denselben Aufbau wie im Backend besitzen und hier nicht genauer erwähnt werden müssen. Sie stellen nur eine weitere Schicht um die JQuery \gls{AJAX}-Schnittstelle dar.